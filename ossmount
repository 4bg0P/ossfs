#!/usr/bin/env perl

# TODO
sub sigint {
    exec("fusermount", "-u", "-z", $mountpoint);
}
$SIG{'INT'} = 'sigint';

my $start_time = time;

use strict;
use warnings;
use POSIX;
use Time::Piece;
use Fuse;
use Net::HTTP;
use MIME::Base64;
use Digest::MD5 qw(md5);
use Digest::HMAC_SHA1;
use XML::Simple;
use Getopt::Long;

my $debug = 0;
my $buffer_size = 1024;

my $host = "storage.aliyun.com";
my $access_id = "acpcwefkoxsh5cygh2uid01p";
my $access_key = "kDyCrM5S16udle+qaGf3mUAhxqQ=";

my %buckets = ();
my $bucket = "";

my $uid = Fuse::fuse_get_context()->{"uid"};
my $gid = Fuse::fuse_get_context()->{"gid"};
my $pid = Fuse::fuse_get_context()->{"pid"};

my %keyword = (
    # sub-query
    "acl" => 1, "group" => 1,
    "uploadId"=> 1, "partNumber" => 1, "uploads" => 1,
    # override
    "response-content-type" => 1,
    "response-content-language" => 1,
    "response-expires" => 1,
    "reponse-cache-control" => 1,
    "response-content-disposition" => 1,
    "response-content-encoding" => 1);

sub debug {
    return unless ($debug);
    my $parent = ( caller(1) )[3];
    $parent = "?" unless (defined($parent));
    foreach (@_) {
        foreach (split /\n/) {
            printf "[%4d] ", time - $start_time;
            print "$parent: $_\n";
        }
    }
}

setlocale(LC_TIME, "C"); # output of strftime is locale-dependent
sub gmtstr {
    return strftime "%a, %d %b %Y %T GMT", gmtime;
}

sub str2gmt {
    my $str = shift @_;
    return Time::Piece->strptime($str, "%a, %d %b %Y %T GMT")->epoch;
}

# $headers will be overwritten
sub oss_request {
    my ($verb, $path, $content, $params_ref, $headers_ref) = @_;

    my %params = $params_ref ? %$params_ref : ();
    my %headers = $headers_ref ? %$headers_ref : ();

    my $content_type = exists($headers{"Content-Type"}) ?
        $headers{"Content-Type"} : "application/octet-stream";
    $headers{"Content-Type"} = $content_type;

    my $content_md5 = $content ? md5($content) : "";
    $headers{"Content-Md5"} = $content_md5;

    my $date = exists($headers{"Date"}) ? $headers{"Date"} : gmtstr();
    $headers{"Date"} = $date;

    my $hmac = Digest::HMAC_SHA1->new($access_key);
    $hmac->add("$verb\n$content_md5\n$content_type\n$date\n");
    foreach my $key ( sort map { lc } keys %headers ) {
        $hmac->add("$key:$headers{$key}\n") if ($key =~ /^x-oss-/);
    }

    my @path_params;
    my @canonicalized_params;
    foreach ( sort keys %params ) {
        my $str = $_;
        $str .= "=" . $params{$_} if (defined($params{$_}));
        push @path_params, $str;
        push @canonicalized_params, $str if (exists($keyword{$_}));
    }
    $path .= "?" . join("&", @path_params) if (@path_params);
    my $canonicalized_resource = $path;
    $canonicalized_resource .= "?" . join("&", @canonicalized_params)
        if (@canonicalized_params);

    $hmac->add($canonicalized_resource);
    $headers{"Authorization"} = "OSS $access_id:" .
        encode_base64($hmac->digest);

    my $conn = Net::HTTP->new(Host => $host,
                              KeepAlive => 1) || die $@;
    debug($conn->format_request($verb => $path, %headers));
    $conn->write_request($verb => $path, %headers, $content);

    %headers = ();
    $content = undef;
    my $code = undef;
    my $remain = "";
    while (1) {
        my $buf;
        my $n = $conn->read_entity_body($buf, $buffer_size);
        die "read failed: $!" unless defined $n;
        last unless $n;
        next if ($n < 0);
        my @lines = split /\n/, $buf, -1;
        $lines[0] = $remain . $lines[0];
        $remain = ($n == $buffer_size) ? pop @lines : "";
        foreach (@lines) {
            debug(length($_) . ": $_");
            unless (defined($code)) {
                if (m/^HTTP/) {
                    (undef, $code) = split / /;
                    next;
                } else {
                    $code = -1; # -1 means no header returned
                    $content = "";
                }
            }
            if ($_ eq "\r") {
                $content = "";
                next;
            }
            if (defined($content)) {
                $content .= "$_\n";
            } elsif (m/([\w-]+): (.*?)\r$/) {
                $headers{$1} = $2;
            } else {
                print STDERR "unknown http response: $_\n";
            }
        }
    }
    return ($code, $content, %headers);
}

sub oss_dummy {
    0;
}

sub oss_getattr {
    my $file = shift @_;
    print STDERR "*** oss_getattr: $file\n";
    if ($file eq "/") {
        return (0, 0, $buckets{$bucket}{"mode"}, 1, $uid, $gid, 0, 0, 0, 0,
                $buckets{$bucket}{"ctime"}, 0, 0);
    } else {
        my ($code, undef, %headers) = oss_request("HEAD", "/$bucket$file");
        if ($code == 200) {
            return (0, # dev
                    0, # inode
                    $buckets{$bucket}{"mode"}, # mode
                    1, # nlink
                    $uid,
                    $gid,
                    0, # rdev
                    $headers{"Content-Length"}, # size
                    0, # atime
                    str2gmt($headers{"Last-Modified"}), # mtime
                    0, # ctime
                    0, # blksize
                    $headers{"Content-Length"} / 512); # blocks
        } else {
            return (0); # TODO
            # return -ENOENT(); # TODO
        }
    }
}

sub oss_mknod {

}

sub oss_getdir {
    my $file = shift @_;
    print STDERR "*** oss_getdir: $file\n";
    $file = "" if ($file eq "/");
    my ($code, $content) = oss_request("GET", "/$bucket$file");
    if ($code == 200) {
        my @ret;
        my $xml = XMLin($content);
        foreach ( @{$xml->{Contents}} ) {
            push @ret, $_->{Key};
        }
        return (@ret, 0);
    } else {
        return -ENOENT(); # TODO
    }
}

sub oss_unlink {
}

sub oss_rmdir {
}

sub oss_rename {
}

sub oss_open {
}

sub oss_read {
}

sub oss_write {
}

sub oss_release {
}

sub oss_access {
}

sub oss_create {
}

sub oss_utimens {
}

sub print_usage {
    print <<EOF;
usage: $0 [options] mountpoint
options:
  -u --unmount  unmount in lazy mode
  -b --bucket   specify bucket name
  -h --help     print this usage
  -d --debug    debug mode
EOF
;
}

my $unmount = 0;
my $test = 0;
GetOptions("u|unmount" => \$unmount,
           "b|bucket=s" => \$bucket,
           "h|help" => sub { &print_usage(); exit 0; },
           "d|debug" => \$debug,
           "t|test" => \$test)
    or exit 1;

my $mountpoint = shift @ARGV;
unless ($mountpoint) {
    print STDERR "mountpoint not specified.\n";
    &print_usage();
    exit 1;
}

# choose a bucket if necessary
unless ($bucket) {
    my ($code, $content) = oss_request("GET", "/");
    print $content, "\n";
    if ($code == 200) {
        my $xml = XMLin($content, ForceArray => ['Buckets']);
        foreach ( @{ $xml->{Buckets} } ) {
            $buckets{$_->{Bucket}->{Name}}{"ctime"} =
                Time::Piece->strptime(
                    $_->{Bucket}->{CreationDate}, "%Y-%m-%dT%T.000Z")->epoch;
            print $_->{Bucket}->{Name}, "\n";
        }
        unless (%buckets) {
            print STDERR "no buckets found.\n";
            print STDERR "please visit http://oss.aliyun.com to create one.\n";
            exit 1;
        }
        while (!exists($buckets{$bucket})) {
            print "please input bucket id: ";
            chomp($bucket = <STDIN>);
        }
    } else {
        print STDERR "failed to list your bucket.\n";
        exit 1;
    }
    ($code, $content) = oss_request("GET", "/$bucket", undef, {"acl" => undef});
    if ($code == 200) {
        my $xml = XMLin($content);
        my %acl = ( "private" => 0770,
                    "public-read" => 0775,
                    "public-read-write" => 0777 );
        my $acl = $xml->{AccessControlList}->{Grant};
        if (exists($acl{$xml->{AccessControlList}->{Grant}})) {
            $buckets{$bucket}{"mode"} = $acl{$xml->{AccessControlList}->{Grant}};
        } else {
            print STDERR "unknown bucket acl: $acl\n";
        }
    } else {
        print STDERR "failed to get bucket acl.\n";
    }
    debug("bucket $bucket ctime: " . $buckets{$bucket}{"ctime"} . "\n");
    debug(sprintf("bucket $bucket mode : %o\n", $buckets{$bucket}{"mode"}));
}

if ($unmount) {
    exec("fusermount", "-u", "-z", $mountpoint);
}

if ($test) {
    print join(", ", oss_getdir("/")), "\n";
    exit 0;
}

Fuse::main( mountpoint => $mountpoint,

            getattr => "main::oss_getattr",
            readlink => "main::oss_dummy",
            getdir => "main::oss_getdir",
            mknod => "main::oss_mknod",
            mkdir => "main::oss_mkdir",
            unlink => "main::oss_unlink",
            rmdir => "main::oss_rmdir",
            symlink => "main::oss_dummy",
            rename => "main::oss_rename",
            link => "main::oss_dummy",
            chmod => "main::oss_dummy",
            chown => "main::oss_dummy",
            truncate => "main::oss_dummy",
            utime => "main:oss_dummy",
            open => "main::oss_open",
            read => "main::oss_read",
            write => "main::oss_write",
            statfs => "main::oss_dummy",
            flush => "main::oss_dummy",
            release => "main::oss_release",
            fsync => "main::oss_dummy",
            setxattr => "main::oss_dummy",
            getxattr => "main::oss_dummy",
            listxattr => "main::oss_dummy",
            removexattr => "main::oss_dummy",
            opendir => "main::oss_dummy",
            # readdir => "main::oss_readdir",
            releasedir => "main::oss_dummy",
            fsyncdir => "main::oss_dummy",

            # init => "main::oss_dummy",
            # destory => "main::oss_dummy",

            access => "main::oss_access",
            create => "main::oss_create",
            ftruncate => "main::dummy",
            fgetattr => "main::oss_getattr",
            lock => "main::dummy",
            utimens => "main::utimens",
            bmap => "main::dummy",
    );
